(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactDOM = factory());
})(this, (function () { 'use strict';

  const FunctionComponent = 0;
  const HostRoot = 3;
  // <div></div>
  const HostComponent = 5;
  const HostText = 6;

  const NoFlags = 0b0000000;
  const Placement = 0b0000001;
  const Update = 0b0000010;
  const childrenDeletion = 0b0000100;
  const MutationMask = Placement | Update | childrenDeletion;

  class FiberNode {
      type;
      tag;
      pendingProps;
      key;
      stateNode;
      ref;
      return;
      sibling;
      child;
      index;
      memoizedProps;
      memoizedState;
      alternate;
      flags;
      subtreeFlags;
      updateQueue;
      constructor(tag, pendingProps, key) {
          // 实例属性
          this.tag = tag;
          this.key = key;
          this.stateNode = null; // 节点对应的实际 DOM 节点或组件实例
          this.type = null; // 节点的类型，可以是原生 DOM 元素、函数组件或类组件等
          //构成树状结构
          this.return = null; // 父fiberNode
          this.sibling = null; // 兄弟fiberNode
          this.child = null; // 子fiberNode
          this.index = 0; // 同级fiber的索引
          this.ref = null;
          // 作为工作单元
          this.pendingProps = pendingProps; // 初始的props
          this.memoizedProps = null; // 工作完成后的props
          this.memoizedState = null;
          this.updateQueue = null;
          this.alternate = null; // 指向节点的备份节点，用于在协调过程中进行比较
          this.flags = NoFlags; // 副作用
          this.subtreeFlags = NoFlags; // 子树的副作用
      }
  }
  class FiberRootNode {
      container; // 保存挂载节点 FiberRootNode
      current; // 指向 hostRootFiber
      finishedWork; // 最后递归完成的 fiber
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
      }
  }
  /** 创建 WorkInProgress*/
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate;
      if (wip === null) {
          // mount
          wip = new FiberNode(current.tag, pendingProps, current.key);
          wip.stateNode = current.stateNode;
          wip.alternate = current;
          current.alternate = wip;
      }
      else {
          // update
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags; // 清除副作用
          wip.subtreeFlags = NoFlags;
      }
      wip.type = current.type;
      wip.updateQueue = current.updateQueue;
      wip.child = current.child;
      wip.memoizedProps = current.memoizedProps;
      wip.memoizedState = current.memoizedState;
      return wip;
  };
  /** 根据element创建fiber并返回 */
  function createFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type === 'string') {
          // <div/>  type: 'div'
          fiberTag = HostComponent;
      }
      else if (typeof type !== 'function' && true) {
          console.warn('未定义的type类型', element);
      }
      // 创建 fiber 节点
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }

  /** 创建 Update */
  const createUpdate = (action) => {
      return {
          action,
      };
  };
  /** 创建 UpdateQueue */
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null,
          },
      };
  };
  /** updateQueue添加update */
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update;
  };
  /** updateQueue消费update */
  const processUpdateQueue = (baseState, // 初始状态
  pendingUpdate // 要消费的Update
  ) => {
      const result = {
          memoizedState: baseState,
      };
      if (pendingUpdate !== null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              // baseState:1, update:(x)=>4*x  ——> memoizedState:4
              result.memoizedState = action(baseState);
          }
          else {
              // baseState:1, update:2  ——>  memoizedState:2
              result.memoizedState = action;
          }
      }
      return result;
  };

  /**
   *  防止比别人滥用ReactElement， 所以要将ReactElement定义为独一无二的Symbol对象
   */
  // 先判断当前的环境是否支持Symbol
  const supportSymbol = typeof Symbol === 'function' && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7;

  /** 实现生成子节点fiber 以及标记Flags的过程 */
  function ChildrenReconciler(shouldTrackEffects) {
      /** 处理单个 Element 节点的情况
        对比 currentFiber 与 ReactElement
        生成 workInProgress FiberNode */
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          // 根据element创建fiber
          const fiber = createFiberFromElement(element);
          fiber.return = returnFiber;
          return fiber;
      }
      /** 处理文本节点的情况
        对比 currentFiber 与 ReactElement
        生成 workInProgress FiberNode */
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      /** 为 Fiber 节点添加更新 flags */
      function placeSingleChild(fiber) {
          // 优化策略，首屏渲染且追踪副作用时，才添加更新 flags
          if (shouldTrackEffects && fiber.alternate === null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      // 闭包，根据 shouldTrackSideEffects 返回不同 reconcileChildFibers 的实现
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断当前fiber的类型
          // 1. 单个 Element 节点
          if (typeof newChild === 'object' && newChild !== null) {
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn('未实现的reconcile类型', newChild);
                      }
                      break;
              }
          }
          // TODO 2. 多个 Element 节点 ul > li*3
          // 3. HostText 节点
          if (typeof newChild === 'string' || typeof newChild === 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          // 4. 其他
          {
              console.warn('未实现的reconcile类型', newChild);
          }
          return null;
      };
  }
  /** 处理更新阶段的子节点协调，组件的更新阶段中，追踪副作用*/
  const reconcileChildFibers = ChildrenReconciler(true);
  /** 处理首次渲染阶段的子节点协调，首屏渲染阶段中不追踪副作用，只对根节点执行一次 DOM 插入操作*/
  const mountChildFibers = ChildrenReconciler(false);

  /** 返回函数组件的子节点 */
  function renderWithHooks(wip) {
      const Component = wip.type;
      const props = wip.pendingProps;
      const children = Component(props);
      return children;
  }

  /**
   * 递归中的递阶段
   *
   * 比较，然后返回子fiberNode
   *  */
  const beginWork = (wip) => {
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip);
          case HostComponent:
              return updateHostComponent(wip);
          case HostText:
              return null;
          case FunctionComponent:
              return updateFunctionComponent(wip);
          default:
              {
                  console.warn('beginWork为实现的类型', wip);
              }
              break;
      }
      return null;
  };
  /** 处理functionComponent的更新 */
  function updateFunctionComponent(wip) {
      const nextChildren = renderWithHooks(wip); // 获取FC的子节点
      reconcileChildren(wip, nextChildren); // 处理子节点更新，可能会递归调用其他协调函数；
      return wip.child;
  }
  /** 处理根节点的更新，包括协调处理根节点的属性 以及子节点的更新逻辑 */
  function updateHostRoot(wip) {
      const baseState = wip.memoizedState;
      const updateQueue = wip.updateQueue;
      const pending = updateQueue.shared.pending;
      updateQueue.shared.pending = null; // 清空更新链表
      // 1.计算状态的最新值
      const { memoizedState } = processUpdateQueue(baseState, pending); // 计算待更新状态的最新值
      wip.memoizedState = memoizedState; // 更新协调后的状态最新值
      // 2. 创造子fiberNode
      const nextChildren = wip.memoizedState; // 获取 children 属性
      reconcileChildren(wip, nextChildren); // 处理根节点的子节点，可能会递归调用其他协调函数；
      // 返回经过协调后的新的子节点链表
      return wip.child;
  }
  function updateHostComponent(wip) {
      const nextProps = wip.pendingProps;
      //  创造子fiberNode
      const nextChildren = nextProps.children; // 获取Dom的children属性
      reconcileChildren(wip, nextChildren); // 处理原生 DOM 元素的子节点更新，可能会递归调用其他协调函数；
      return wip.child;
  }
  /** 通过对比子节点的 current FiberNode 与 子节点的 ReactElement，来生成子节点对应的 workInProgress FiberNode */
  function reconcileChildren(wip, children) {
      const current = wip.alternate;
      if (current !== null) {
          // update
          wip.child = reconcileChildFibers(wip, current?.child, children);
      }
      else {
          // mount
          wip.child = mountChildFibers(wip, null, children);
      }
  }

  /**
   * 描述数组环境方法
   */
  /** 创建Dom实例 */
  // export const createInstance = (type: string, props: any): Instance => {
  const createInstance = (type) => {
      // TODO 处理props
      const element = document.createElement(type);
      return element;
  };
  /** Dom 的插入 */
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child);
  };
  /** 创建Text 节点 */
  const createTextInstance = (content) => {
      return document.createTextNode(content);
  };
  /** 插入节点 */
  const appendChildToContainer = appendInitialChild;

  let nextEffect = null;
  const CommitMutationEffects = (finishedWork) => {
      nextEffect = finishedWork;
      while (nextEffect !== null) {
          // 向下遍历
          const child = nextEffect.child;
          if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
              child !== null) {
              //  子节点有可能存在Mutation对应的操作
              nextEffect = child;
          }
          else {
              up: while (nextEffect !== null) {
                  // 找到第一个没有 subtreeFlags 的节点, 即最下的 flag 处
                  commitMutationEffectsOnFiber(nextEffect);
                  // 向上遍历 DFS
                  const sibling = nextEffect.sibling;
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  nextEffect = nextEffect.return;
              }
          }
      }
  };
  /** 对 Fiber节点的 Mutation 操作 */
  const commitMutationEffectsOnFiber = (finishedWork) => {
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          // 存在 Placement 操作
          commitPlacement(finishedWork);
          finishedWork.flags &= ~Placement; //移除Placement
      }
  };
  const commitPlacement = (finishedWork) => {
      {
          console.warn('执行Placement操作', finishedWork);
      }
      // 找到parentDom
      const hostParent = getHostParent(finishedWork);
      if (hostParent !== null) {
          appendPlacementNodeIntoContainer(finishedWork, hostParent);
      }
      // 找到finishedWork对应的Dom 然后 append 到 hostParent
  };
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent) {
          const parentTag = parent.tag;
          // HostComponent HostRoot
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.warn('未找到host parent');
      }
      return null;
  }
  function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
      // 只有 tag 为HostComponent或HostText可以直接插入
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          appendChildToContainer(hostParent, finishedWork.stateNode);
          return;
      }
      // 否则，递归向下寻找
      const child = finishedWork.child;
      if (child !== null) {
          appendPlacementNodeIntoContainer(child, hostParent);
          let sibling = child.sibling;
          while (sibling !== null) {
              appendPlacementNodeIntoContainer(sibling, hostParent);
              sibling = sibling.sibling;
          }
      }
  }

  /**
   * 递归中的归阶段
   * 生成更新计划，计算和收集更新 flags
   *  */
  const completeWork = (wip) => {
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      switch (wip.tag) {
          case HostComponent:
              if (current !== null && wip.stateNode) ;
              else {
                  // mount  构建离屏的 Dom 树
                  // 1. 构建 Dom
                  // const instance = createInstance(wip.type, newProps)
                  const instance = createInstance(wip.type);
                  // 2. 将Dom插入到Dom树中
                  appendAllChildren(instance, wip);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case HostText:
              if (current !== null && wip.stateNode) ;
              else {
                  // mount
                  // 1. 构建 Dom
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case HostRoot:
              bubbleProperties(wip);
              return null;
          case FunctionComponent:
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn('completeWork未实现的类型', wip);
              }
              return null;
      }
  };
  /** 节点的插入方法 */
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      // 递归插入
      while (node !== null) {
          if (node?.tag === HostComponent || node?.tag === HostText) {
              // 插入原生 DOM 元素节点或文本节点
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              // 递归处理其他类型的组件节点的子节点
              node.child.return = node;
              node = node.child;
              continue;
          }
          // 终止条件
          if (node === wip) {
              return;
          }
          // 子节点结束，开始处理兄弟节点
          while (node.sibling === null) {
              // 1.当前节点无兄弟节点
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node?.return;
          }
          // 2.当前节点有兄弟节点
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  /** 收集更新 flags，将子 FiberNode 的 flags 冒泡到父 FiberNode 上 */
  function bubbleProperties(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  /**
   * 整体 reconciler 的工作循环
   */
  /** 指向当前正在工作的 fiberNode */
  let workInProgress = null;
  /** 初始化 */
  function prepareFreshStack(root) {
      workInProgress = createWorkInProgress(root.current, {});
  }
  /** 实现在 updateContainer后进入wordLoop更新流程 */
  function scheduleUpdateOnFiber(fiber) {
      // TODO 调度功能
      // fiberRootNode 先找到当前触发更新节点的根节点
      const root = markUpdateFromFiberToRoot(fiber);
      renderRoot(root);
  }
  /** 从当前fiber找到根fiber */
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = node.return;
      while (parent !== null) {
          // 往上找
          node = parent;
          parent = node.return;
      }
      if (node.tag === HostRoot) {
          return node.stateNode;
      }
      return null;
  }
  /** reconciler最终执行的方法 */
  function renderRoot(root) {
      prepareFreshStack(root);
      // 开始更新流程: 递归
      do {
          try {
              workLoop();
              break;
          }
          catch (error) {
              console.warn('workLoop发生错误');
              workInProgress = null;
          }
      } while (true);
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      // 提交阶段的入口函数
      commitRoot(root);
  }
  /** 进入commit阶段 */
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return;
      }
      {
          console.warn('commit阶段开始', finishedWork);
      }
      // 重置
      root.finishedWork = null;
      // 判断是否存在 3 个子阶段需要执行的操作
      // 使用 MutationMask 判断是否存在副作用
      const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags; // subtree
      const rootHasEffects = (finishedWork.flags & MutationMask) !== NoFlags; // root
      if (subtreeHasEffect || rootHasEffects) {
          // 1.beforeMutation
          // 2.mutation
          CommitMutationEffects(finishedWork); // 有副作用则进入Mutation阶段
          root.current = finishedWork; // finishedWork 是新生成的 workInProgress 树
          // 3.layout
      }
      else {
          root.current = finishedWork; // 完成 Fiber 树的切换
      }
  }
  function workLoop() {
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber); // 递
      fiber.memoizedProps = fiber.pendingProps;
      if (next === null) {
          completeUnitOfWork(fiber); // 归
      }
      else {
          workInProgress = next; // 继续执行workLoop, 向下遍历
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          const next = completeWork(node); // 归返回兄弟节点
          if (next !== null) {
              workInProgress = next;
              return;
          }
          const sibling = node.sibling;
          if (sibling !== null) {
              // 兄弟节点存在
              workInProgress = sibling;
              return;
          }
          // 兄弟节点不存在
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }

  function createContainer(container) {
      // 1.新建 hostRootFiber
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      // 2.新建 fiberRootNode
      const root = new FiberRootNode(container, hostRootFiber);
      // 3.初始化hostRootFiber的updateQueue
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  }
  function updateContainer(element, root) {
      // 1.获取 hostRootFiber
      const hostRootFiber = root.current;
      // 2.新建 update
      const update = createUpdate(element);
      // 3.将该 update 插入到 hostRootFiber的updateQueue中
      enqueueUpdate(hostRootFiber.updateQueue, update);
      // 进入wordLoop更新流程
      scheduleUpdateOnFiber(hostRootFiber);
      return element;
  }

  // ReactDom.createRoot(root).render(<App/>)
  function createRoot(container) {
      const root = createContainer(container);
      return {
          render(element) {
              updateContainer(element, root);
          },
      };
  }

  var ReactDom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  /**
   * 打包出的 React-Dom 包
   */

  return ReactDom;

}));
